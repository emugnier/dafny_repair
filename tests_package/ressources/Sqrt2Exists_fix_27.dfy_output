lemma Sqrt2Exists() returns (sqrt2: real)
    ensures sqrt2 * sqrt2 == 2.0
  {
    var lower := iset x: real | x >= 0.0 && Square(x) < 2.0;
    var upper := iset x: real | x >= 0.0 && Square(x) > 2.0;
    forall x <- lower, y <- upper ensures x < y {
      if x >= y {
        calc {
          2.0;
        <
          Square(y);
        <= { RealArith.MulMonotonic(y, y, x); RealArith.MulMonotonic(x, y, x); }
          Square(x);
        <
          2.0;
        }
      }
    }
        assert 2.0 in upper;
<assertion> Insert assertion here </assertion>
    sqrt2 := Reals.DedekindCompleteness(lower, upper);
    assert 1.0 <= sqrt2 <= 2.0;
    assert Square(sqrt2) == 2.0 by {
      if sqrt2 * sqrt2 > 2.0 {
        var eps := (sqrt2 * sqrt2 - 2.0) / (2.0 * sqrt2);
        assert 0.0 < eps < 1.0;
        var y := sqrt2 - eps;
        assert y * y > 2.0 by {
          calc {
            y * y;
            sqrt2 * sqrt2 - 2.0 * sqrt2 * eps + eps * eps;
            sqrt2 * sqrt2 - (sqrt2 * sqrt2 - 2.0) + eps * eps;
            2.0 + eps * eps;
          >
            2.0;
          }
        }
        assert y in upper by {
          assert y >= 0.0;
          assert y * y > 2.0;
        }
        assert false;
      }
      if sqrt2 * sqrt2 < 2.0 {
        var eps := (2.0 - sqrt2 * sqrt2) / (2.0 * sqrt2 + 1.0);
        assert 0.0 < eps < 1.0;
        var y := sqrt2 + eps;
        assert y * y < 2.0 by {
          calc {
            y * y;
            sqrt2 * sqrt2 + 2.0 * sqrt2 * eps + eps * eps;
            sqrt2 * sqrt2 + (2.0 * sqrt2 + eps) * eps;
          < { RealArith.MulMonotonicStrict(eps, 2.0 * sqrt2 + eps, 2.0 * sqrt2 + 1.0); }
            sqrt2 * sqrt2 + (2.0 * sqrt2 + 1.0) * eps;
            sqrt2 * sqrt2 + (2.0 - sqrt2 * sqrt2);
            2.0;
          }
        }
        assert y in lower by {
          assert y >= 0.0;
          assert y * y < 2.0;
        }
        assert false;
      }
    }
  }