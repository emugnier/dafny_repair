lemma LubUndefUbUndef(t1 : Type, t2 : Type, t : Type, m: ValidationMode)
    requires !LubDefined(t1, t2, m)
    ensures !subty(t1, t, m) || !subty(t2, t, m)
  {
    match t {
      case Never =>
      case Int =>
      case String =>
      case Bool(b) =>
      case Entity(e) =>
      case Set(e) => {
        if t1.Set? && t2.Set? {
          LubUndefUbUndef(t1.ty, t2.ty, e, m);
        }
      }
      case Record(rt) => {
        match (t1, t2) {
          case (Record(rt1), Record(rt2)) => {
            if m.isStrict() {
              
              if exists k | k in rt1.attrs.Keys && k in rt2.attrs.Keys :: !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m) {
                var k :| k in rt1.attrs.Keys && k in rt2.attrs.Keys && !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m);
                if k in rt.attrs.Keys {
                  assert (exists k' | k' in rt.attrs.Keys && k' in rt1.attrs.Keys :: !subtyAttrType(rt1.attrs[k'], rt.attrs[k'], m)) ||
                         (exists k' | k' in rt.attrs.Keys && k' in rt2.attrs.Keys :: !subtyAttrType(rt2.attrs[k'], rt.attrs[k'], m));
<assertion> Insert assertion here </assertion>
                }
<assertion> Insert assertion here </assertion>
              }
            } else {
              assert lubRecordType(rt1, rt2, ValidationMode.Permissive).Ok?;
            }
          }
          case _ =>
        }
      }
      case Extension(e) =>
    }
  }