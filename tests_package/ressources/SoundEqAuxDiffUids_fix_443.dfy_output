lemma SoundEqAuxDiffUids(u1: EntityUID, u2: EntityUID, t: Type, effs: Effects)
      requires Typesafe(BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),effs,t)
      requires u1 != u2
      ensures IsSafe(r,s,BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),t) {
      var e1: Expr := PrimitiveLit(Primitive.EntityUID(u1));
      var e2: Expr := PrimitiveLit(Primitive.EntityUID(u2));
      var t' :| getType(BinaryApp(BinaryOp.Eq,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);
            // Somehow, these unused variables help nudge Dafny to complete the proof.
<assertion> Insert assertion here </assertion>
      var t1 := getType(e1,effs);
      var t2 := getType(e2,effs);
      assert t' == Type.Bool(False);
      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t') by { EqEntityDiffSafe(r,s,u1,u2); }
      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t) by {
        SubtyCompat(t',t);
        SemSubtyTransport(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t',t); }
    }